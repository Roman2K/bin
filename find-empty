#!/usr/bin/env ruby

##
# Quick test setup:
#
#   mkdir a a/b a/b/c b b/c b/d c && touch b/c/d
#

require 'set'

module Empties
  IGNORED = %w(.DS_Store)

  class Basic
    def call(path)
      if empty? path
        delete(path)
      end
    end

  protected

    def empty?(path)
      entries(path).empty?
    end

    def entries(path)
      (Dir.entries(path) - %w(. ..) - IGNORED)
    end
  end

  class TrashDeleter < Basic
  protected
    def delete(path)
      cmd = ["trash", path]
      system(*cmd, err: '/dev/null')
      if !$?.success?
        unless $?.exitstatus == 1 && !File.exist?(path)
          raise "command failed: %p" % cmd
        end
      end
    end
  end

  class PrintDeleter < Basic
    def initialize(*args, &block)
      super
      @deleted = []
    end

  protected

    def delete(path)
      @deleted << path
      puts(path)
    end

    def empty?(path)
      entries(path).all? { |e| @deleted.include?(File.join(path, e)) }
    end
  end
end

default_cmd = 'print'

cmd = ARGV.shift || default_cmd

deleter =
  if cmd == 'print'
    Empties::PrintDeleter.new
  elsif cmd == 'trash'
    Empties::TrashDeleter.new
  elsif File.directory?(cmd)
    ARGV.unshift(cmd)
    Empties::PrintDeleter.new
  else
    raise ArgumentError, "unrecognized command: %p" % cmd
  end

entry_points = ARGV.dup.tap { |list| list << '.' if list.empty? }

dirs = entry_points.flat_map do |d|
  Dir[d + '/**/*'].select do |path|
    File.directory? path
  end
end

dirs.sort.reverse.each do |dir|
  deleter.call(dir)
end
